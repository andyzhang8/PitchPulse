"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pitchfinder";
exports.ids = ["vendor-chunks/pitchfinder"];
exports.modules = {

/***/ "(rsc)/./node_modules/pitchfinder/lib/detectors/acf2plus.js":
/*!************************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/acf2plus.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_PARAMS = {\n    sampleRate: 44100,\n};\nfunction ACF2PLUS(params) {\n    if (params === void 0) { params = DEFAULT_PARAMS; }\n    var config = __assign(__assign({}, DEFAULT_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    // Implements the ACF2+ algorithm\n    return function ACF2PLUSDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var rms = 0;\n        var i, j, u, tmp;\n        for (i = 0; i < maxShift; i++) {\n            tmp = float32AudioBuffer[i];\n            rms += tmp * tmp;\n        }\n        rms = Math.sqrt(rms / maxShift);\n        if (rms < 0.01)\n            // not enough signal\n            return -1;\n        /* Trimming cuts the edges of the signal so that it starts and ends near zero.\n         This is used to neutralize an inherent instability of the ACF version I use.*/\n        var aux1 = 0;\n        var aux2 = maxShift - 1;\n        var thres = 0.2;\n        for (i = 0; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[i]) < thres) {\n                aux1 = i;\n                break;\n            }\n        for (i = 1; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[maxShift - i]) < thres) {\n                aux2 = maxShift - i;\n                break;\n            }\n        var frames = float32AudioBuffer.slice(aux1, aux2);\n        var framesLength = frames.length;\n        var calcSub = new Array(framesLength).fill(0);\n        for (i = 0; i < framesLength; i++)\n            for (j = 0; j < framesLength - i; j++)\n                calcSub[i] = calcSub[i] + frames[j] * frames[j + i];\n        u = 0;\n        while (calcSub[u] > calcSub[u + 1])\n            u++;\n        var maxval = -1, maxpos = -1;\n        for (i = u; i < framesLength; i++) {\n            if (calcSub[i] > maxval) {\n                maxval = calcSub[i];\n                maxpos = i;\n            }\n        }\n        var T0 = maxpos;\n        /* Interpolation is parabolic interpolation. It helps with precision.\n         We suppose that a parabola pass through the three points that comprise the peak.\n         'a' and 'b' are the unknowns from the linear equation system\n         and b/(2a) is the \"error\" in the abscissa.\n         y1,y2,y3 are the ordinates.*/\n        var y1 = calcSub[T0 - 1], y2 = calcSub[T0], y3 = calcSub[T0 + 1];\n        var a = (y1 + y3 - 2 * y2) / 2;\n        var b = (y3 - y1) / 2;\n        if (a)\n            T0 = T0 - b / (2 * a);\n        return sampleRate / T0;\n    };\n}\nexports.ACF2PLUS = ACF2PLUS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy9hY2YycGx1cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL21udC9jL1VzZXJzL2FuZHl6L0Rvd25sb2Fkcy9BY291c3RpY0FJL25vZGVfbW9kdWxlcy9waXRjaGZpbmRlci9saWIvZGV0ZWN0b3JzL2FjZjJwbHVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX1BBUkFNUyA9IHtcbiAgICBzYW1wbGVSYXRlOiA0NDEwMCxcbn07XG5mdW5jdGlvbiBBQ0YyUExVUyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0gREVGQVVMVF9QQVJBTVM7IH1cbiAgICB2YXIgY29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfUEFSQU1TKSwgcGFyYW1zKTtcbiAgICB2YXIgc2FtcGxlUmF0ZSA9IGNvbmZpZy5zYW1wbGVSYXRlO1xuICAgIC8vIEltcGxlbWVudHMgdGhlIEFDRjIrIGFsZ29yaXRobVxuICAgIHJldHVybiBmdW5jdGlvbiBBQ0YyUExVU0RldGVjdG9yKGZsb2F0MzJBdWRpb0J1ZmZlcikge1xuICAgICAgICB2YXIgbWF4U2hpZnQgPSBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoO1xuICAgICAgICB2YXIgcm1zID0gMDtcbiAgICAgICAgdmFyIGksIGosIHUsIHRtcDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heFNoaWZ0OyBpKyspIHtcbiAgICAgICAgICAgIHRtcCA9IGZsb2F0MzJBdWRpb0J1ZmZlcltpXTtcbiAgICAgICAgICAgIHJtcyArPSB0bXAgKiB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgcm1zID0gTWF0aC5zcXJ0KHJtcyAvIG1heFNoaWZ0KTtcbiAgICAgICAgaWYgKHJtcyA8IDAuMDEpXG4gICAgICAgICAgICAvLyBub3QgZW5vdWdoIHNpZ25hbFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvKiBUcmltbWluZyBjdXRzIHRoZSBlZGdlcyBvZiB0aGUgc2lnbmFsIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG5lYXIgemVyby5cbiAgICAgICAgIFRoaXMgaXMgdXNlZCB0byBuZXV0cmFsaXplIGFuIGluaGVyZW50IGluc3RhYmlsaXR5IG9mIHRoZSBBQ0YgdmVyc2lvbiBJIHVzZS4qL1xuICAgICAgICB2YXIgYXV4MSA9IDA7XG4gICAgICAgIHZhciBhdXgyID0gbWF4U2hpZnQgLSAxO1xuICAgICAgICB2YXIgdGhyZXMgPSAwLjI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXhTaGlmdCAvIDI7IGkrKylcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhmbG9hdDMyQXVkaW9CdWZmZXJbaV0pIDwgdGhyZXMpIHtcbiAgICAgICAgICAgICAgICBhdXgxID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1heFNoaWZ0IC8gMjsgaSsrKVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGZsb2F0MzJBdWRpb0J1ZmZlclttYXhTaGlmdCAtIGldKSA8IHRocmVzKSB7XG4gICAgICAgICAgICAgICAgYXV4MiA9IG1heFNoaWZ0IC0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgdmFyIGZyYW1lcyA9IGZsb2F0MzJBdWRpb0J1ZmZlci5zbGljZShhdXgxLCBhdXgyKTtcbiAgICAgICAgdmFyIGZyYW1lc0xlbmd0aCA9IGZyYW1lcy5sZW5ndGg7XG4gICAgICAgIHZhciBjYWxjU3ViID0gbmV3IEFycmF5KGZyYW1lc0xlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyYW1lc0xlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZyYW1lc0xlbmd0aCAtIGk7IGorKylcbiAgICAgICAgICAgICAgICBjYWxjU3ViW2ldID0gY2FsY1N1YltpXSArIGZyYW1lc1tqXSAqIGZyYW1lc1tqICsgaV07XG4gICAgICAgIHUgPSAwO1xuICAgICAgICB3aGlsZSAoY2FsY1N1Ylt1XSA+IGNhbGNTdWJbdSArIDFdKVxuICAgICAgICAgICAgdSsrO1xuICAgICAgICB2YXIgbWF4dmFsID0gLTEsIG1heHBvcyA9IC0xO1xuICAgICAgICBmb3IgKGkgPSB1OyBpIDwgZnJhbWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxjU3ViW2ldID4gbWF4dmFsKSB7XG4gICAgICAgICAgICAgICAgbWF4dmFsID0gY2FsY1N1YltpXTtcbiAgICAgICAgICAgICAgICBtYXhwb3MgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBUMCA9IG1heHBvcztcbiAgICAgICAgLyogSW50ZXJwb2xhdGlvbiBpcyBwYXJhYm9saWMgaW50ZXJwb2xhdGlvbi4gSXQgaGVscHMgd2l0aCBwcmVjaXNpb24uXG4gICAgICAgICBXZSBzdXBwb3NlIHRoYXQgYSBwYXJhYm9sYSBwYXNzIHRocm91Z2ggdGhlIHRocmVlIHBvaW50cyB0aGF0IGNvbXByaXNlIHRoZSBwZWFrLlxuICAgICAgICAgJ2EnIGFuZCAnYicgYXJlIHRoZSB1bmtub3ducyBmcm9tIHRoZSBsaW5lYXIgZXF1YXRpb24gc3lzdGVtXG4gICAgICAgICBhbmQgYi8oMmEpIGlzIHRoZSBcImVycm9yXCIgaW4gdGhlIGFic2Npc3NhLlxuICAgICAgICAgeTEseTIseTMgYXJlIHRoZSBvcmRpbmF0ZXMuKi9cbiAgICAgICAgdmFyIHkxID0gY2FsY1N1YltUMCAtIDFdLCB5MiA9IGNhbGNTdWJbVDBdLCB5MyA9IGNhbGNTdWJbVDAgKyAxXTtcbiAgICAgICAgdmFyIGEgPSAoeTEgKyB5MyAtIDIgKiB5MikgLyAyO1xuICAgICAgICB2YXIgYiA9ICh5MyAtIHkxKSAvIDI7XG4gICAgICAgIGlmIChhKVxuICAgICAgICAgICAgVDAgPSBUMCAtIGIgLyAoMiAqIGEpO1xuICAgICAgICByZXR1cm4gc2FtcGxlUmF0ZSAvIFQwO1xuICAgIH07XG59XG5leHBvcnRzLkFDRjJQTFVTID0gQUNGMlBMVVM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/detectors/acf2plus.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/detectors/amdf.js":
/*!********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/amdf.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_AMDF_PARAMS = {\n    sampleRate: 44100,\n    minFrequency: 82,\n    maxFrequency: 1000,\n    ratio: 5,\n    sensitivity: 0.1,\n};\nfunction AMDF(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_AMDF_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    var minFrequency = config.minFrequency;\n    var maxFrequency = config.maxFrequency;\n    var sensitivity = config.sensitivity;\n    var ratio = config.ratio;\n    var amd = [];\n    /* Round in such a way that both exact minPeriod as\n     exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n     thus ensuring that minFrequency and maxFrequency can be found\n     even in edge cases */\n    var maxPeriod = Math.ceil(sampleRate / minFrequency);\n    var minPeriod = Math.floor(sampleRate / maxFrequency);\n    return function AMDFDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var t = 0;\n        var minval = Infinity;\n        var maxval = -Infinity;\n        var frames1, frames2, calcSub, i, j, u, aux1, aux2;\n        // Find the average magnitude difference for each possible period offset.\n        for (i = 0; i < maxShift; i++) {\n            if (minPeriod <= i && i <= maxPeriod) {\n                for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n                    frames1[t] = float32AudioBuffer[aux1];\n                    frames2[t] = float32AudioBuffer[aux2];\n                }\n                // Take the difference between these frames.\n                var frameLength = frames1.length;\n                calcSub = [];\n                for (u = 0; u < frameLength; u++) {\n                    calcSub[u] = frames1[u] - frames2[u];\n                }\n                // Sum the differences.\n                var summation = 0;\n                for (u = 0; u < frameLength; u++) {\n                    summation += Math.abs(calcSub[u]);\n                }\n                amd[i] = summation;\n            }\n        }\n        for (j = minPeriod; j < maxPeriod; j++) {\n            if (amd[j] < minval)\n                minval = amd[j];\n            if (amd[j] > maxval)\n                maxval = amd[j];\n        }\n        var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n        for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++)\n            ;\n        var searchLength = minPeriod / 2;\n        minval = amd[j];\n        var minpos = j;\n        for (i = j - 1; i < j + searchLength && i <= maxPeriod; i++) {\n            if (amd[i] < minval) {\n                minval = amd[i];\n                minpos = i;\n            }\n        }\n        if (Math.round(amd[minpos] * ratio) < maxval) {\n            return sampleRate / minpos;\n        }\n        else {\n            return null;\n        }\n    };\n}\nexports.AMDF = AMDF;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy9hbWRmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLDRFQUE0RSxxQkFBcUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL21udC9jL1VzZXJzL2FuZHl6L0Rvd25sb2Fkcy9BY291c3RpY0FJL25vZGVfbW9kdWxlcy9waXRjaGZpbmRlci9saWIvZGV0ZWN0b3JzL2FtZGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERFRkFVTFRfQU1ERl9QQVJBTVMgPSB7XG4gICAgc2FtcGxlUmF0ZTogNDQxMDAsXG4gICAgbWluRnJlcXVlbmN5OiA4MixcbiAgICBtYXhGcmVxdWVuY3k6IDEwMDAsXG4gICAgcmF0aW86IDUsXG4gICAgc2Vuc2l0aXZpdHk6IDAuMSxcbn07XG5mdW5jdGlvbiBBTURGKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHZhciBjb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9BTURGX1BBUkFNUyksIHBhcmFtcyk7XG4gICAgdmFyIHNhbXBsZVJhdGUgPSBjb25maWcuc2FtcGxlUmF0ZTtcbiAgICB2YXIgbWluRnJlcXVlbmN5ID0gY29uZmlnLm1pbkZyZXF1ZW5jeTtcbiAgICB2YXIgbWF4RnJlcXVlbmN5ID0gY29uZmlnLm1heEZyZXF1ZW5jeTtcbiAgICB2YXIgc2Vuc2l0aXZpdHkgPSBjb25maWcuc2Vuc2l0aXZpdHk7XG4gICAgdmFyIHJhdGlvID0gY29uZmlnLnJhdGlvO1xuICAgIHZhciBhbWQgPSBbXTtcbiAgICAvKiBSb3VuZCBpbiBzdWNoIGEgd2F5IHRoYXQgYm90aCBleGFjdCBtaW5QZXJpb2QgYXNcbiAgICAgZXhhY3QgbWF4UGVyaW9kIGxpZSBpbnNpZGUgdGhlIHJvdW5kZWQgc3BhbiBtaW5QZXJpb2QtbWF4UGVyaW9kLFxuICAgICB0aHVzIGVuc3VyaW5nIHRoYXQgbWluRnJlcXVlbmN5IGFuZCBtYXhGcmVxdWVuY3kgY2FuIGJlIGZvdW5kXG4gICAgIGV2ZW4gaW4gZWRnZSBjYXNlcyAqL1xuICAgIHZhciBtYXhQZXJpb2QgPSBNYXRoLmNlaWwoc2FtcGxlUmF0ZSAvIG1pbkZyZXF1ZW5jeSk7XG4gICAgdmFyIG1pblBlcmlvZCA9IE1hdGguZmxvb3Ioc2FtcGxlUmF0ZSAvIG1heEZyZXF1ZW5jeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEFNREZEZXRlY3RvcihmbG9hdDMyQXVkaW9CdWZmZXIpIHtcbiAgICAgICAgdmFyIG1heFNoaWZ0ID0gZmxvYXQzMkF1ZGlvQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICB2YXIgbWludmFsID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXh2YWwgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBmcmFtZXMxLCBmcmFtZXMyLCBjYWxjU3ViLCBpLCBqLCB1LCBhdXgxLCBhdXgyO1xuICAgICAgICAvLyBGaW5kIHRoZSBhdmVyYWdlIG1hZ25pdHVkZSBkaWZmZXJlbmNlIGZvciBlYWNoIHBvc3NpYmxlIHBlcmlvZCBvZmZzZXQuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXhTaGlmdDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWluUGVyaW9kIDw9IGkgJiYgaSA8PSBtYXhQZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGF1eDEgPSAwLCBhdXgyID0gaSwgdCA9IDAsIGZyYW1lczEgPSBbXSwgZnJhbWVzMiA9IFtdOyBhdXgxIDwgbWF4U2hpZnQgLSBpOyB0KyssIGF1eDIrKywgYXV4MSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lczFbdF0gPSBmbG9hdDMyQXVkaW9CdWZmZXJbYXV4MV07XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lczJbdF0gPSBmbG9hdDMyQXVkaW9CdWZmZXJbYXV4Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVzZSBmcmFtZXMuXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gZnJhbWVzMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2FsY1N1YiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCBmcmFtZUxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNTdWJbdV0gPSBmcmFtZXMxW3VdIC0gZnJhbWVzMlt1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3VtIHRoZSBkaWZmZXJlbmNlcy5cbiAgICAgICAgICAgICAgICB2YXIgc3VtbWF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgZnJhbWVMZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXRpb24gKz0gTWF0aC5hYnMoY2FsY1N1Ylt1XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFtZFtpXSA9IHN1bW1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSBtaW5QZXJpb2Q7IGogPCBtYXhQZXJpb2Q7IGorKykge1xuICAgICAgICAgICAgaWYgKGFtZFtqXSA8IG1pbnZhbClcbiAgICAgICAgICAgICAgICBtaW52YWwgPSBhbWRbal07XG4gICAgICAgICAgICBpZiAoYW1kW2pdID4gbWF4dmFsKVxuICAgICAgICAgICAgICAgIG1heHZhbCA9IGFtZFtqXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3V0b2ZmID0gTWF0aC5yb3VuZChzZW5zaXRpdml0eSAqIChtYXh2YWwgLSBtaW52YWwpICsgbWludmFsKTtcbiAgICAgICAgZm9yIChqID0gbWluUGVyaW9kOyBqIDw9IG1heFBlcmlvZCAmJiBhbWRbal0gPiBjdXRvZmY7IGorKylcbiAgICAgICAgICAgIDtcbiAgICAgICAgdmFyIHNlYXJjaExlbmd0aCA9IG1pblBlcmlvZCAvIDI7XG4gICAgICAgIG1pbnZhbCA9IGFtZFtqXTtcbiAgICAgICAgdmFyIG1pbnBvcyA9IGo7XG4gICAgICAgIGZvciAoaSA9IGogLSAxOyBpIDwgaiArIHNlYXJjaExlbmd0aCAmJiBpIDw9IG1heFBlcmlvZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYW1kW2ldIDwgbWludmFsKSB7XG4gICAgICAgICAgICAgICAgbWludmFsID0gYW1kW2ldO1xuICAgICAgICAgICAgICAgIG1pbnBvcyA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGgucm91bmQoYW1kW21pbnBvc10gKiByYXRpbykgPCBtYXh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVSYXRlIC8gbWlucG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5BTURGID0gQU1ERjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/detectors/amdf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\nvar DEFAULT_DYNAMIC_WAVELET_CONFIG = {\n    sampleRate: 44100,\n};\nfunction DynamicWavelet(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_DYNAMIC_WAVELET_CONFIG), params);\n    var sampleRate = config.sampleRate;\n    return function DynamicWaveletDetector(float32AudioBuffer) {\n        var mins = [];\n        var maxs = [];\n        var bufferLength = float32AudioBuffer.length;\n        var freq = null;\n        var theDC = 0;\n        var minValue = 0;\n        var maxValue = 0;\n        // Compute max amplitude, amplitude threshold, and the DC.\n        for (var i = 0; i < bufferLength; i++) {\n            var sample = float32AudioBuffer[i];\n            theDC = theDC + sample;\n            maxValue = Math.max(maxValue, sample);\n            minValue = Math.min(minValue, sample);\n        }\n        theDC /= bufferLength;\n        minValue -= theDC;\n        maxValue -= theDC;\n        var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n        var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n        // levels, start without downsampling...\n        var curLevel = 0;\n        var curModeDistance = -1;\n        var curSamNb = float32AudioBuffer.length;\n        var delta, nbMaxs, nbMins;\n        // Search:\n        while (true) {\n            delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n            if (curSamNb < 2)\n                break;\n            var dv = void 0;\n            var previousDV = -1000;\n            var lastMinIndex = -1000000;\n            var lastMaxIndex = -1000000;\n            var findMax = false;\n            var findMin = false;\n            nbMins = 0;\n            nbMaxs = 0;\n            for (var i = 2; i < curSamNb; i++) {\n                var si = float32AudioBuffer[i] - theDC;\n                var si1 = float32AudioBuffer[i - 1] - theDC;\n                if (si1 <= 0 && si > 0)\n                    findMax = true;\n                if (si1 >= 0 && si < 0)\n                    findMin = true;\n                // min or max ?\n                dv = si - si1;\n                if (previousDV > -1000) {\n                    if (findMin && previousDV < 0 && dv >= 0) {\n                        // minimum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMinIndex + delta) {\n                                mins[nbMins++] = i;\n                                lastMinIndex = i;\n                                findMin = false;\n                            }\n                        }\n                    }\n                    if (findMax && previousDV > 0 && dv <= 0) {\n                        // maximum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMaxIndex + delta) {\n                                maxs[nbMaxs++] = i;\n                                lastMaxIndex = i;\n                                findMax = false;\n                            }\n                        }\n                    }\n                }\n                previousDV = dv;\n            }\n            if (nbMins === 0 && nbMaxs === 0) {\n                // No best distance found!\n                break;\n            }\n            var d = void 0;\n            var distances = [];\n            for (var i = 0; i < curSamNb; i++) {\n                distances[i] = 0;\n            }\n            for (var i = 0; i < nbMins; i++) {\n                for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n                    if (i + j < nbMins) {\n                        d = Math.abs(mins[i] - mins[i + j]);\n                        distances[d] += 1;\n                    }\n                }\n            }\n            var bestDistance = -1;\n            var bestValue = -1;\n            for (var i = 0; i < curSamNb; i++) {\n                var summed = 0;\n                for (var j = -1 * delta; j <= delta; j++) {\n                    if (i + j >= 0 && i + j < curSamNb) {\n                        summed += distances[i + j];\n                    }\n                }\n                if (summed === bestValue) {\n                    if (i === 2 * bestDistance) {\n                        bestDistance = i;\n                    }\n                }\n                else if (summed > bestValue) {\n                    bestValue = summed;\n                    bestDistance = i;\n                }\n            }\n            // averaging\n            var distAvg = 0;\n            var nbDists = 0;\n            for (var j = -delta; j <= delta; j++) {\n                if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {\n                    var nbDist = distances[bestDistance + j];\n                    if (nbDist > 0) {\n                        nbDists += nbDist;\n                        distAvg += (bestDistance + j) * nbDist;\n                    }\n                }\n            }\n            // This is our mode distance.\n            distAvg /= nbDists;\n            // Continue the levels?\n            if (curModeDistance > -1) {\n                if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n                    // two consecutive similar mode distances : ok !\n                    freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n                    break;\n                }\n            }\n            // not similar, continue next level;\n            curModeDistance = distAvg;\n            curLevel++;\n            if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n                break;\n            }\n            //do not modify original audio buffer, make a copy buffer, if\n            //downsampling is needed (only once).\n            var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n            if (curSamNb === distances.length) {\n                newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n            }\n            for (var i = 0; i < curSamNb / 2; i++) {\n                newFloat32AudioBuffer[i] =\n                    (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;\n            }\n            float32AudioBuffer = newFloat32AudioBuffer;\n            curSamNb /= 2;\n        }\n        return freq;\n    };\n}\nexports.DynamicWavelet = DynamicWavelet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy9keW5hbWljX3dhdmVsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvbW50L2MvVXNlcnMvYW5keXovRG93bmxvYWRzL0Fjb3VzdGljQUkvbm9kZV9tb2R1bGVzL3BpdGNoZmluZGVyL2xpYi9kZXRlY3RvcnMvZHluYW1pY193YXZlbGV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNQVhfRkxXVF9MRVZFTFMgPSA2O1xudmFyIE1BWF9GID0gMzAwMDtcbnZhciBESUZGRVJFTkNFX0xFVkVMU19OID0gMztcbnZhciBNQVhJTUFfVEhSRVNIT0xEX1JBVElPID0gMC43NTtcbnZhciBERUZBVUxUX0RZTkFNSUNfV0FWRUxFVF9DT05GSUcgPSB7XG4gICAgc2FtcGxlUmF0ZTogNDQxMDAsXG59O1xuZnVuY3Rpb24gRHluYW1pY1dhdmVsZXQocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgdmFyIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX0RZTkFNSUNfV0FWRUxFVF9DT05GSUcpLCBwYXJhbXMpO1xuICAgIHZhciBzYW1wbGVSYXRlID0gY29uZmlnLnNhbXBsZVJhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIER5bmFtaWNXYXZlbGV0RGV0ZWN0b3IoZmxvYXQzMkF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIHZhciBtaW5zID0gW107XG4gICAgICAgIHZhciBtYXhzID0gW107XG4gICAgICAgIHZhciBidWZmZXJMZW5ndGggPSBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoO1xuICAgICAgICB2YXIgZnJlcSA9IG51bGw7XG4gICAgICAgIHZhciB0aGVEQyA9IDA7XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IDA7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IDA7XG4gICAgICAgIC8vIENvbXB1dGUgbWF4IGFtcGxpdHVkZSwgYW1wbGl0dWRlIHRocmVzaG9sZCwgYW5kIHRoZSBEQy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNhbXBsZSA9IGZsb2F0MzJBdWRpb0J1ZmZlcltpXTtcbiAgICAgICAgICAgIHRoZURDID0gdGhlREMgKyBzYW1wbGU7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCBzYW1wbGUpO1xuICAgICAgICAgICAgbWluVmFsdWUgPSBNYXRoLm1pbihtaW5WYWx1ZSwgc2FtcGxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVEQyAvPSBidWZmZXJMZW5ndGg7XG4gICAgICAgIG1pblZhbHVlIC09IHRoZURDO1xuICAgICAgICBtYXhWYWx1ZSAtPSB0aGVEQztcbiAgICAgICAgdmFyIGFtcGxpdHVkZU1heCA9IG1heFZhbHVlID4gLTEgKiBtaW5WYWx1ZSA/IG1heFZhbHVlIDogLTEgKiBtaW5WYWx1ZTtcbiAgICAgICAgdmFyIGFtcGxpdHVkZVRocmVzaG9sZCA9IGFtcGxpdHVkZU1heCAqIE1BWElNQV9USFJFU0hPTERfUkFUSU87XG4gICAgICAgIC8vIGxldmVscywgc3RhcnQgd2l0aG91dCBkb3duc2FtcGxpbmcuLi5cbiAgICAgICAgdmFyIGN1ckxldmVsID0gMDtcbiAgICAgICAgdmFyIGN1ck1vZGVEaXN0YW5jZSA9IC0xO1xuICAgICAgICB2YXIgY3VyU2FtTmIgPSBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoO1xuICAgICAgICB2YXIgZGVsdGEsIG5iTWF4cywgbmJNaW5zO1xuICAgICAgICAvLyBTZWFyY2g6XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBkZWx0YSA9IH5+KHNhbXBsZVJhdGUgLyAoTWF0aC5wb3coMiwgY3VyTGV2ZWwpICogTUFYX0YpKTtcbiAgICAgICAgICAgIGlmIChjdXJTYW1OYiA8IDIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgZHYgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEViA9IC0xMDAwO1xuICAgICAgICAgICAgdmFyIGxhc3RNaW5JbmRleCA9IC0xMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGxhc3RNYXhJbmRleCA9IC0xMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGZpbmRNYXggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBmaW5kTWluID0gZmFsc2U7XG4gICAgICAgICAgICBuYk1pbnMgPSAwO1xuICAgICAgICAgICAgbmJNYXhzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgY3VyU2FtTmI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzaSA9IGZsb2F0MzJBdWRpb0J1ZmZlcltpXSAtIHRoZURDO1xuICAgICAgICAgICAgICAgIHZhciBzaTEgPSBmbG9hdDMyQXVkaW9CdWZmZXJbaSAtIDFdIC0gdGhlREM7XG4gICAgICAgICAgICAgICAgaWYgKHNpMSA8PSAwICYmIHNpID4gMClcbiAgICAgICAgICAgICAgICAgICAgZmluZE1heCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNpMSA+PSAwICYmIHNpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZmluZE1pbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gbWluIG9yIG1heCA/XG4gICAgICAgICAgICAgICAgZHYgPSBzaSAtIHNpMTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNEViA+IC0xMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kTWluICYmIHByZXZpb3VzRFYgPCAwICYmIGR2ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbmltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzaSkgPj0gYW1wbGl0dWRlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBsYXN0TWluSW5kZXggKyBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5zW25iTWlucysrXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNaW5JbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRNaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmRNYXggJiYgcHJldmlvdXNEViA+IDAgJiYgZHYgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNpKSA+PSBhbXBsaXR1ZGVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGxhc3RNYXhJbmRleCArIGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heHNbbmJNYXhzKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1heEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZE1heCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c0RWID0gZHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmJNaW5zID09PSAwICYmIG5iTWF4cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGJlc3QgZGlzdGFuY2UgZm91bmQhXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyU2FtTmI7IGkrKykge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iTWluczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBESUZGRVJFTkNFX0xFVkVMU19OOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyBqIDwgbmJNaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5hYnMobWluc1tpXSAtIG1pbnNbaSArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tkXSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJlc3REaXN0YW5jZSA9IC0xO1xuICAgICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJTYW1OYjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bW1lZCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IC0xICogZGVsdGE7IGogPD0gZGVsdGE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIGogPj0gMCAmJiBpICsgaiA8IGN1clNhbU5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tZWQgKz0gZGlzdGFuY2VzW2kgKyBqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VtbWVkID09PSBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDIgKiBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3REaXN0YW5jZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VtbWVkID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHN1bW1lZDtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdmVyYWdpbmdcbiAgICAgICAgICAgIHZhciBkaXN0QXZnID0gMDtcbiAgICAgICAgICAgIHZhciBuYkRpc3RzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAtZGVsdGE7IGogPD0gZGVsdGE7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChiZXN0RGlzdGFuY2UgKyBqID49IDAgJiYgYmVzdERpc3RhbmNlICsgaiA8IGJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmJEaXN0ID0gZGlzdGFuY2VzW2Jlc3REaXN0YW5jZSArIGpdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmJEaXN0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmJEaXN0cyArPSBuYkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0QXZnICs9IChiZXN0RGlzdGFuY2UgKyBqKSAqIG5iRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgb3VyIG1vZGUgZGlzdGFuY2UuXG4gICAgICAgICAgICBkaXN0QXZnIC89IG5iRGlzdHM7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB0aGUgbGV2ZWxzP1xuICAgICAgICAgICAgaWYgKGN1ck1vZGVEaXN0YW5jZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RBdmcgKiAyIC0gY3VyTW9kZURpc3RhbmNlKSA8PSAyICogZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGNvbnNlY3V0aXZlIHNpbWlsYXIgbW9kZSBkaXN0YW5jZXMgOiBvayAhXG4gICAgICAgICAgICAgICAgICAgIGZyZXEgPSBzYW1wbGVSYXRlIC8gKE1hdGgucG93KDIsIGN1ckxldmVsIC0gMSkgKiBjdXJNb2RlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3Qgc2ltaWxhciwgY29udGludWUgbmV4dCBsZXZlbDtcbiAgICAgICAgICAgIGN1ck1vZGVEaXN0YW5jZSA9IGRpc3RBdmc7XG4gICAgICAgICAgICBjdXJMZXZlbCsrO1xuICAgICAgICAgICAgaWYgKGN1ckxldmVsID49IE1BWF9GTFdUX0xFVkVMUyB8fCBjdXJTYW1OYiA8IDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZG8gbm90IG1vZGlmeSBvcmlnaW5hbCBhdWRpbyBidWZmZXIsIG1ha2UgYSBjb3B5IGJ1ZmZlciwgaWZcbiAgICAgICAgICAgIC8vZG93bnNhbXBsaW5nIGlzIG5lZWRlZCAob25seSBvbmNlKS5cbiAgICAgICAgICAgIHZhciBuZXdGbG9hdDMyQXVkaW9CdWZmZXIgPSBmbG9hdDMyQXVkaW9CdWZmZXIuc3ViYXJyYXkoMCk7XG4gICAgICAgICAgICBpZiAoY3VyU2FtTmIgPT09IGRpc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXdGbG9hdDMyQXVkaW9CdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGN1clNhbU5iIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1clNhbU5iIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3RmxvYXQzMkF1ZGlvQnVmZmVyW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGZsb2F0MzJBdWRpb0J1ZmZlclsyICogaV0gKyBmbG9hdDMyQXVkaW9CdWZmZXJbMiAqIGkgKyAxXSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxvYXQzMkF1ZGlvQnVmZmVyID0gbmV3RmxvYXQzMkF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgY3VyU2FtTmIgLz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJlcTtcbiAgICB9O1xufVxuZXhwb3J0cy5EeW5hbWljV2F2ZWxldCA9IER5bmFtaWNXYXZlbGV0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/detectors/macleod.js":
/*!***********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/macleod.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_MACLEOD_PARAMS = {\n    bufferSize: 1024,\n    cutoff: 0.97,\n    sampleRate: 44100,\n};\nfunction Macleod(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_MACLEOD_PARAMS), params);\n    var bufferSize = config.bufferSize, cutoff = config.cutoff, sampleRate = config.sampleRate;\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    var SMALL_CUTOFF = 0.5;\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    var LOWER_PITCH_CUTOFF = 80;\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    var nsdf = new Float32Array(bufferSize);\n    /**\n     * Contains a sum of squares of the Buffer, for improving performance\n     * (avoids redoing math in the normalized square difference function)\n     */\n    var squaredBufferSum = new Float32Array(bufferSize);\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    var turningPointX;\n    var turningPointY;\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    var maxPositions = [];\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    var periodEstimates = [];\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    var ampEstimates = [];\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    function normalizedSquareDifference(float32AudioBuffer) {\n        var acf;\n        var divisorM;\n        squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n        for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n            squaredBufferSum[i] =\n                float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n        }\n        for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n            acf = 0;\n            divisorM =\n                squaredBufferSum[float32AudioBuffer.length - 1 - tau] +\n                    squaredBufferSum[float32AudioBuffer.length - 1] -\n                    squaredBufferSum[tau];\n            for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n                acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n            }\n            nsdf[tau] = (2 * acf) / divisorM;\n        }\n    }\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    function parabolicInterpolation(tau) {\n        var nsdfa = nsdf[tau - 1], nsdfb = nsdf[tau], nsdfc = nsdf[tau + 1], bValue = tau, bottom = nsdfc + nsdfa - 2 * nsdfb;\n        if (bottom === 0) {\n            turningPointX = bValue;\n            turningPointY = nsdfb;\n        }\n        else {\n            var delta = nsdfa - nsdfc;\n            turningPointX = bValue + delta / (2 * bottom);\n            turningPointY = nsdfb - (delta * delta) / (8 * bottom);\n        }\n    }\n    // Finds the highest value between each pair of positive zero crossings.\n    function peakPicking() {\n        var pos = 0;\n        var curMaxPos = 0;\n        // find the first negative zero crossing.\n        while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n            pos++;\n        }\n        // loop over all the values below zero.\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++;\n        }\n        // can happen if output[0] is NAN\n        if (pos == 0) {\n            pos = 1;\n        }\n        while (pos < nsdf.length - 1) {\n            if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n                if (curMaxPos == 0) {\n                    // the first max (between zero crossings)\n                    curMaxPos = pos;\n                }\n                else if (nsdf[pos] > nsdf[curMaxPos]) {\n                    // a higher max (between the zero crossings)\n                    curMaxPos = pos;\n                }\n            }\n            pos++;\n            // a negative zero crossing\n            if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                // if there was a maximum add it to the list of maxima\n                if (curMaxPos > 0) {\n                    maxPositions.push(curMaxPos);\n                    curMaxPos = 0; // clear the maximum position, so we start\n                    // looking for a new ones\n                }\n                while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                    pos++; // loop over all the values below zero\n                }\n            }\n        }\n        if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n        }\n    }\n    return function Macleod(float32AudioBuffer) {\n        // 0. Clear old results.\n        var pitch;\n        maxPositions = [];\n        periodEstimates = [];\n        ampEstimates = [];\n        // 1. Calculute the normalized square difference for each Tau value.\n        normalizedSquareDifference(float32AudioBuffer);\n        // 2. Peak picking time: time to pick some peaks.\n        peakPicking();\n        var highestAmplitude = -Infinity;\n        for (var i = 0; i < maxPositions.length; i++) {\n            var tau = maxPositions[i];\n            // make sure every annotation has a probability attached\n            highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n            if (nsdf[tau] > SMALL_CUTOFF) {\n                // calculates turningPointX and Y\n                parabolicInterpolation(tau);\n                // store the turning points\n                ampEstimates.push(turningPointY);\n                periodEstimates.push(turningPointX);\n                // remember the highest amplitude\n                highestAmplitude = Math.max(highestAmplitude, turningPointY);\n            }\n        }\n        if (periodEstimates.length) {\n            // use the overall maximum to calculate a cutoff.\n            // The cutoff value is based on the highest value and a relative\n            // threshold.\n            var actualCutoff = cutoff * highestAmplitude;\n            var periodIndex = 0;\n            for (var i = 0; i < ampEstimates.length; i++) {\n                if (ampEstimates[i] >= actualCutoff) {\n                    periodIndex = i;\n                    break;\n                }\n            }\n            var period = periodEstimates[periodIndex], pitchEstimate = sampleRate / period;\n            if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n                pitch = pitchEstimate;\n            }\n            else {\n                pitch = -1;\n            }\n        }\n        else {\n            // no pitch detected.\n            pitch = -1;\n        }\n        return {\n            probability: highestAmplitude,\n            freq: pitch,\n        };\n    };\n}\nexports.Macleod = Macleod;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy9tYWNsZW9kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy9hbmR5ei9Eb3dubG9hZHMvQWNvdXN0aWNBSS9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy9tYWNsZW9kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX01BQ0xFT0RfUEFSQU1TID0ge1xuICAgIGJ1ZmZlclNpemU6IDEwMjQsXG4gICAgY3V0b2ZmOiAwLjk3LFxuICAgIHNhbXBsZVJhdGU6IDQ0MTAwLFxufTtcbmZ1bmN0aW9uIE1hY2xlb2QocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgdmFyIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX01BQ0xFT0RfUEFSQU1TKSwgcGFyYW1zKTtcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IGNvbmZpZy5idWZmZXJTaXplLCBjdXRvZmYgPSBjb25maWcuY3V0b2ZmLCBzYW1wbGVSYXRlID0gY29uZmlnLnNhbXBsZVJhdGU7XG4gICAgLyoqXG4gICAgICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHBlYWtzIGJlbG93IHRoaXMgY3V0b2ZmIGFyZSBub3QgZXZlbiBjb25zaWRlcmVkLlxuICAgICAqL1xuICAgIHZhciBTTUFMTF9DVVRPRkYgPSAwLjU7XG4gICAgLyoqXG4gICAgICogUGl0Y2ggYW5ub3RhdGlvbnMgYmVsb3cgdGhpcyB0aHJlc2hvbGQgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCwgdGhleSBhcmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHZhciBMT1dFUl9QSVRDSF9DVVRPRkYgPSA4MDtcbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhIG5vcm1hbGl6ZWQgc3F1YXJlIGRpZmZlcmVuY2UgZnVuY3Rpb24gdmFsdWUgZm9yIGVhY2ggZGVsYXlcbiAgICAgKiAodGF1KS5cbiAgICAgKi9cbiAgICB2YXIgbnNkZiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgYSBzdW0gb2Ygc3F1YXJlcyBvZiB0aGUgQnVmZmVyLCBmb3IgaW1wcm92aW5nIHBlcmZvcm1hbmNlXG4gICAgICogKGF2b2lkcyByZWRvaW5nIG1hdGggaW4gdGhlIG5vcm1hbGl6ZWQgc3F1YXJlIGRpZmZlcmVuY2UgZnVuY3Rpb24pXG4gICAgICovXG4gICAgdmFyIHNxdWFyZWRCdWZmZXJTdW0gPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICAgIC8qKlxuICAgICAqIFRoZSB4IGFuZCB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBvZiB0aGUgY3VydmUgKG5zZGYpLlxuICAgICAqL1xuICAgIHZhciB0dXJuaW5nUG9pbnRYO1xuICAgIHZhciB0dXJuaW5nUG9pbnRZO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCB3aXRoIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIG9mIHRoZSBuc2RmIGN1cnZlLlxuICAgICAqL1xuICAgIHZhciBtYXhQb3NpdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZXN0aW1hdGVzIG9mIHRoZSBwZXJpb2Qgb2YgdGhlIHNpZ25hbCAoaW4gc2FtcGxlcykuXG4gICAgICovXG4gICAgdmFyIHBlcmlvZEVzdGltYXRlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBlc3RpbWF0ZXMgb2YgdGhlIGFtcGxpdHVkZXMgY29ycmVzcG9uZGluZyB3aXRoIHRoZSBwZXJpb2RcbiAgICAgKiBlc3RpbWF0ZXMuXG4gICAgICovXG4gICAgdmFyIGFtcEVzdGltYXRlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIG5vcm1hbGl6ZWQgc3F1YXJlIGRpZmZlcmVuY2UgZnVuY3Rpb24uIFNlZSBzZWN0aW9uIDQgKGFuZFxuICAgICAqIHRoZSBleHBsYW5hdGlvbiBiZWZvcmUpIGluIHRoZSBNUE0gYXJ0aWNsZS4gVGhpcyBjYWxjdWxhdGlvbiBjYW4gYmVcbiAgICAgKiBvcHRpbWl6ZWQgYnkgdXNpbmcgYW4gRkZULiBUaGUgcmVzdWx0cyBzaG91bGQgcmVtYWluIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZWRTcXVhcmVEaWZmZXJlbmNlKGZsb2F0MzJBdWRpb0J1ZmZlcikge1xuICAgICAgICB2YXIgYWNmO1xuICAgICAgICB2YXIgZGl2aXNvck07XG4gICAgICAgIHNxdWFyZWRCdWZmZXJTdW1bMF0gPSBmbG9hdDMyQXVkaW9CdWZmZXJbMF0gKiBmbG9hdDMyQXVkaW9CdWZmZXJbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmxvYXQzMkF1ZGlvQnVmZmVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBzcXVhcmVkQnVmZmVyU3VtW2ldID1cbiAgICAgICAgICAgICAgICBmbG9hdDMyQXVkaW9CdWZmZXJbaV0gKiBmbG9hdDMyQXVkaW9CdWZmZXJbaV0gKyBzcXVhcmVkQnVmZmVyU3VtW2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0YXUgPSAwOyB0YXUgPCBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoOyB0YXUrKykge1xuICAgICAgICAgICAgYWNmID0gMDtcbiAgICAgICAgICAgIGRpdmlzb3JNID1cbiAgICAgICAgICAgICAgICBzcXVhcmVkQnVmZmVyU3VtW2Zsb2F0MzJBdWRpb0J1ZmZlci5sZW5ndGggLSAxIC0gdGF1XSArXG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZWRCdWZmZXJTdW1bZmxvYXQzMkF1ZGlvQnVmZmVyLmxlbmd0aCAtIDFdIC1cbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZEJ1ZmZlclN1bVt0YXVdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoIC0gdGF1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY2YgKz0gZmxvYXQzMkF1ZGlvQnVmZmVyW2ldICogZmxvYXQzMkF1ZGlvQnVmZmVyW2kgKyB0YXVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnNkZlt0YXVdID0gKDIgKiBhY2YpIC8gZGl2aXNvck07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHggdmFsdWUgY29ycmVzcG9uZGluZyB3aXRoIHRoZSBwZWFrIG9mIGEgcGFyYWJvbGEuXG4gICAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gdGhyZWUgY29uc2VjdXRpdmUgcG9pbnRzIGNlbnRlcmVkIG9uIHRhdS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJhYm9saWNJbnRlcnBvbGF0aW9uKHRhdSkge1xuICAgICAgICB2YXIgbnNkZmEgPSBuc2RmW3RhdSAtIDFdLCBuc2RmYiA9IG5zZGZbdGF1XSwgbnNkZmMgPSBuc2RmW3RhdSArIDFdLCBiVmFsdWUgPSB0YXUsIGJvdHRvbSA9IG5zZGZjICsgbnNkZmEgLSAyICogbnNkZmI7XG4gICAgICAgIGlmIChib3R0b20gPT09IDApIHtcbiAgICAgICAgICAgIHR1cm5pbmdQb2ludFggPSBiVmFsdWU7XG4gICAgICAgICAgICB0dXJuaW5nUG9pbnRZID0gbnNkZmI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBuc2RmYSAtIG5zZGZjO1xuICAgICAgICAgICAgdHVybmluZ1BvaW50WCA9IGJWYWx1ZSArIGRlbHRhIC8gKDIgKiBib3R0b20pO1xuICAgICAgICAgICAgdHVybmluZ1BvaW50WSA9IG5zZGZiIC0gKGRlbHRhICogZGVsdGEpIC8gKDggKiBib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmRzIHRoZSBoaWdoZXN0IHZhbHVlIGJldHdlZW4gZWFjaCBwYWlyIG9mIHBvc2l0aXZlIHplcm8gY3Jvc3NpbmdzLlxuICAgIGZ1bmN0aW9uIHBlYWtQaWNraW5nKCkge1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIGN1ck1heFBvcyA9IDA7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IG5lZ2F0aXZlIHplcm8gY3Jvc3NpbmcuXG4gICAgICAgIHdoaWxlIChwb3MgPCAobnNkZi5sZW5ndGggLSAxKSAvIDMgJiYgbnNkZltwb3NdID4gMCkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCB0aGUgdmFsdWVzIGJlbG93IHplcm8uXG4gICAgICAgIHdoaWxlIChwb3MgPCBuc2RmLmxlbmd0aCAtIDEgJiYgbnNkZltwb3NdIDw9IDApIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBoYXBwZW4gaWYgb3V0cHV0WzBdIGlzIE5BTlxuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBvcyA8IG5zZGYubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKG5zZGZbcG9zXSA+IG5zZGZbcG9zIC0gMV0gJiYgbnNkZltwb3NdID49IG5zZGZbcG9zICsgMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyTWF4UG9zID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IG1heCAoYmV0d2VlbiB6ZXJvIGNyb3NzaW5ncylcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF4UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuc2RmW3Bvc10gPiBuc2RmW2N1ck1heFBvc10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBoaWdoZXIgbWF4IChiZXR3ZWVuIHRoZSB6ZXJvIGNyb3NzaW5ncylcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF4UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgLy8gYSBuZWdhdGl2ZSB6ZXJvIGNyb3NzaW5nXG4gICAgICAgICAgICBpZiAocG9zIDwgbnNkZi5sZW5ndGggLSAxICYmIG5zZGZbcG9zXSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgbWF4aW11bSBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgbWF4aW1hXG4gICAgICAgICAgICAgICAgaWYgKGN1ck1heFBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnB1c2goY3VyTWF4UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF4UG9zID0gMDsgLy8gY2xlYXIgdGhlIG1heGltdW0gcG9zaXRpb24sIHNvIHdlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2tpbmcgZm9yIGEgbmV3IG9uZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5zZGYubGVuZ3RoIC0gMSAmJiBuc2RmW3Bvc10gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKzsgLy8gbG9vcCBvdmVyIGFsbCB0aGUgdmFsdWVzIGJlbG93IHplcm9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ck1heFBvcyA+IDApIHtcbiAgICAgICAgICAgIG1heFBvc2l0aW9ucy5wdXNoKGN1ck1heFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIE1hY2xlb2QoZmxvYXQzMkF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIC8vIDAuIENsZWFyIG9sZCByZXN1bHRzLlxuICAgICAgICB2YXIgcGl0Y2g7XG4gICAgICAgIG1heFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBwZXJpb2RFc3RpbWF0ZXMgPSBbXTtcbiAgICAgICAgYW1wRXN0aW1hdGVzID0gW107XG4gICAgICAgIC8vIDEuIENhbGN1bHV0ZSB0aGUgbm9ybWFsaXplZCBzcXVhcmUgZGlmZmVyZW5jZSBmb3IgZWFjaCBUYXUgdmFsdWUuXG4gICAgICAgIG5vcm1hbGl6ZWRTcXVhcmVEaWZmZXJlbmNlKGZsb2F0MzJBdWRpb0J1ZmZlcik7XG4gICAgICAgIC8vIDIuIFBlYWsgcGlja2luZyB0aW1lOiB0aW1lIHRvIHBpY2sgc29tZSBwZWFrcy5cbiAgICAgICAgcGVha1BpY2tpbmcoKTtcbiAgICAgICAgdmFyIGhpZ2hlc3RBbXBsaXR1ZGUgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4UG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGF1ID0gbWF4UG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGFubm90YXRpb24gaGFzIGEgcHJvYmFiaWxpdHkgYXR0YWNoZWRcbiAgICAgICAgICAgIGhpZ2hlc3RBbXBsaXR1ZGUgPSBNYXRoLm1heChoaWdoZXN0QW1wbGl0dWRlLCBuc2RmW3RhdV0pO1xuICAgICAgICAgICAgaWYgKG5zZGZbdGF1XSA+IFNNQUxMX0NVVE9GRikge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZXMgdHVybmluZ1BvaW50WCBhbmQgWVxuICAgICAgICAgICAgICAgIHBhcmFib2xpY0ludGVycG9sYXRpb24odGF1KTtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgdHVybmluZyBwb2ludHNcbiAgICAgICAgICAgICAgICBhbXBFc3RpbWF0ZXMucHVzaCh0dXJuaW5nUG9pbnRZKTtcbiAgICAgICAgICAgICAgICBwZXJpb2RFc3RpbWF0ZXMucHVzaCh0dXJuaW5nUG9pbnRYKTtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgaGlnaGVzdCBhbXBsaXR1ZGVcbiAgICAgICAgICAgICAgICBoaWdoZXN0QW1wbGl0dWRlID0gTWF0aC5tYXgoaGlnaGVzdEFtcGxpdHVkZSwgdHVybmluZ1BvaW50WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmlvZEVzdGltYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgb3ZlcmFsbCBtYXhpbXVtIHRvIGNhbGN1bGF0ZSBhIGN1dG9mZi5cbiAgICAgICAgICAgIC8vIFRoZSBjdXRvZmYgdmFsdWUgaXMgYmFzZWQgb24gdGhlIGhpZ2hlc3QgdmFsdWUgYW5kIGEgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRocmVzaG9sZC5cbiAgICAgICAgICAgIHZhciBhY3R1YWxDdXRvZmYgPSBjdXRvZmYgKiBoaWdoZXN0QW1wbGl0dWRlO1xuICAgICAgICAgICAgdmFyIHBlcmlvZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1wRXN0aW1hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFtcEVzdGltYXRlc1tpXSA+PSBhY3R1YWxDdXRvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGVyaW9kID0gcGVyaW9kRXN0aW1hdGVzW3BlcmlvZEluZGV4XSwgcGl0Y2hFc3RpbWF0ZSA9IHNhbXBsZVJhdGUgLyBwZXJpb2Q7XG4gICAgICAgICAgICBpZiAocGl0Y2hFc3RpbWF0ZSA+IExPV0VSX1BJVENIX0NVVE9GRikge1xuICAgICAgICAgICAgICAgIHBpdGNoID0gcGl0Y2hFc3RpbWF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpdGNoID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBwaXRjaCBkZXRlY3RlZC5cbiAgICAgICAgICAgIHBpdGNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2JhYmlsaXR5OiBoaWdoZXN0QW1wbGl0dWRlLFxuICAgICAgICAgICAgZnJlcTogcGl0Y2gsXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmV4cG9ydHMuTWFjbGVvZCA9IE1hY2xlb2Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/detectors/macleod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/detectors/yin.js":
/*!*******************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/yin.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_YIN_PARAMS = {\n    threshold: 0.1,\n    sampleRate: 44100,\n    probabilityThreshold: 0.1,\n};\nfunction YIN(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_YIN_PARAMS), params);\n    var threshold = config.threshold, sampleRate = config.sampleRate, probabilityThreshold = config.probabilityThreshold;\n    return function YINDetector(float32AudioBuffer) {\n        // Set buffer size to the highest power of two below the provided buffer's length.\n        var bufferSize;\n        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2)\n            ;\n        bufferSize /= 2;\n        // Set up the yinBuffer as described in step one of the YIN paper.\n        var yinBufferLength = bufferSize / 2;\n        var yinBuffer = new Float32Array(yinBufferLength);\n        var probability = 0, tau;\n        // Compute the difference function as described in step 2 of the YIN paper.\n        for (var t = 0; t < yinBufferLength; t++) {\n            yinBuffer[t] = 0;\n        }\n        for (var t = 1; t < yinBufferLength; t++) {\n            for (var i = 0; i < yinBufferLength; i++) {\n                var delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];\n                yinBuffer[t] += delta * delta;\n            }\n        }\n        // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n        yinBuffer[0] = 1;\n        yinBuffer[1] = 1;\n        var runningSum = 0;\n        for (var t = 1; t < yinBufferLength; t++) {\n            runningSum += yinBuffer[t];\n            yinBuffer[t] *= t / runningSum;\n        }\n        // Compute the absolute threshold as described in step 4 of the paper.\n        // Since the first two positions in the array are 1,\n        // we can start at the third position.\n        for (tau = 2; tau < yinBufferLength; tau++) {\n            if (yinBuffer[tau] < threshold) {\n                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n                    tau++;\n                }\n                // found tau, exit loop and return\n                // store the probability\n                // From the YIN paper: The threshold determines the list of\n                // candidates admitted to the set, and can be interpreted as the\n                // proportion of aperiodic power tolerated\n                // within a periodic signal.\n                //\n                // Since we want the periodicity and and not aperiodicity:\n                // periodicity = 1 - aperiodicity\n                probability = 1 - yinBuffer[tau];\n                break;\n            }\n        }\n        // if no pitch found, return null.\n        if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n            return null;\n        }\n        // If probability too low, return -1.\n        if (probability < probabilityThreshold) {\n            return null;\n        }\n        /**\n         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n         * value using parabolic interpolation. This is needed to detect higher\n         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n         * for more background\n         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n         */\n        var betterTau, x0, x2;\n        if (tau < 1) {\n            x0 = tau;\n        }\n        else {\n            x0 = tau - 1;\n        }\n        if (tau + 1 < yinBufferLength) {\n            x2 = tau + 1;\n        }\n        else {\n            x2 = tau;\n        }\n        if (x0 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x2]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x2;\n            }\n        }\n        else if (x2 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x0]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x0;\n            }\n        }\n        else {\n            var s0 = yinBuffer[x0];\n            var s1 = yinBuffer[tau];\n            var s2 = yinBuffer[x2];\n            // fixed AUBIO implementation, thanks to Karl Helgason:\n            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n        }\n        return sampleRate / betterTau;\n    };\n}\nexports.YIN = YIN;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy95aW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUF3QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0MsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVciLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy9hbmR5ei9Eb3dubG9hZHMvQWNvdXN0aWNBSS9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2RldGVjdG9ycy95aW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICBDb3B5cmlnaHQgKEMpIDIwMDMtMjAwOSBQYXVsIEJyb3NzaWVyIDxwaWVtQGF1YmlvLm9yZz5cbiAgVGhpcyBmaWxlIGlzIHBhcnQgb2YgYXViaW8uXG4gIGF1YmlvIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAgYXViaW8gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICBhbG9uZyB3aXRoIGF1YmlvLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVGQVVMVF9ZSU5fUEFSQU1TID0ge1xuICAgIHRocmVzaG9sZDogMC4xLFxuICAgIHNhbXBsZVJhdGU6IDQ0MTAwLFxuICAgIHByb2JhYmlsaXR5VGhyZXNob2xkOiAwLjEsXG59O1xuZnVuY3Rpb24gWUlOKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHZhciBjb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9ZSU5fUEFSQU1TKSwgcGFyYW1zKTtcbiAgICB2YXIgdGhyZXNob2xkID0gY29uZmlnLnRocmVzaG9sZCwgc2FtcGxlUmF0ZSA9IGNvbmZpZy5zYW1wbGVSYXRlLCBwcm9iYWJpbGl0eVRocmVzaG9sZCA9IGNvbmZpZy5wcm9iYWJpbGl0eVRocmVzaG9sZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gWUlORGV0ZWN0b3IoZmxvYXQzMkF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIC8vIFNldCBidWZmZXIgc2l6ZSB0byB0aGUgaGlnaGVzdCBwb3dlciBvZiB0d28gYmVsb3cgdGhlIHByb3ZpZGVkIGJ1ZmZlcidzIGxlbmd0aC5cbiAgICAgICAgdmFyIGJ1ZmZlclNpemU7XG4gICAgICAgIGZvciAoYnVmZmVyU2l6ZSA9IDE7IGJ1ZmZlclNpemUgPCBmbG9hdDMyQXVkaW9CdWZmZXIubGVuZ3RoOyBidWZmZXJTaXplICo9IDIpXG4gICAgICAgICAgICA7XG4gICAgICAgIGJ1ZmZlclNpemUgLz0gMjtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSB5aW5CdWZmZXIgYXMgZGVzY3JpYmVkIGluIHN0ZXAgb25lIG9mIHRoZSBZSU4gcGFwZXIuXG4gICAgICAgIHZhciB5aW5CdWZmZXJMZW5ndGggPSBidWZmZXJTaXplIC8gMjtcbiAgICAgICAgdmFyIHlpbkJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoeWluQnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb2JhYmlsaXR5ID0gMCwgdGF1O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGZ1bmN0aW9uIGFzIGRlc2NyaWJlZCBpbiBzdGVwIDIgb2YgdGhlIFlJTiBwYXBlci5cbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB5aW5CdWZmZXJMZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgeWluQnVmZmVyW3RdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IHlpbkJ1ZmZlckxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHlpbkJ1ZmZlckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZmxvYXQzMkF1ZGlvQnVmZmVyW2ldIC0gZmxvYXQzMkF1ZGlvQnVmZmVyW2kgKyB0XTtcbiAgICAgICAgICAgICAgICB5aW5CdWZmZXJbdF0gKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjdW11bGF0aXZlIG1lYW4gbm9ybWFsaXplZCBkaWZmZXJlbmNlIGFzIGRlc2NyaWJlZCBpbiBzdGVwIDMgb2YgdGhlIHBhcGVyLlxuICAgICAgICB5aW5CdWZmZXJbMF0gPSAxO1xuICAgICAgICB5aW5CdWZmZXJbMV0gPSAxO1xuICAgICAgICB2YXIgcnVubmluZ1N1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgeWluQnVmZmVyTGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHJ1bm5pbmdTdW0gKz0geWluQnVmZmVyW3RdO1xuICAgICAgICAgICAgeWluQnVmZmVyW3RdICo9IHQgLyBydW5uaW5nU3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFic29sdXRlIHRocmVzaG9sZCBhcyBkZXNjcmliZWQgaW4gc3RlcCA0IG9mIHRoZSBwYXBlci5cbiAgICAgICAgLy8gU2luY2UgdGhlIGZpcnN0IHR3byBwb3NpdGlvbnMgaW4gdGhlIGFycmF5IGFyZSAxLFxuICAgICAgICAvLyB3ZSBjYW4gc3RhcnQgYXQgdGhlIHRoaXJkIHBvc2l0aW9uLlxuICAgICAgICBmb3IgKHRhdSA9IDI7IHRhdSA8IHlpbkJ1ZmZlckxlbmd0aDsgdGF1KyspIHtcbiAgICAgICAgICAgIGlmICh5aW5CdWZmZXJbdGF1XSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0YXUgKyAxIDwgeWluQnVmZmVyTGVuZ3RoICYmIHlpbkJ1ZmZlclt0YXUgKyAxXSA8IHlpbkJ1ZmZlclt0YXVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhdSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmb3VuZCB0YXUsIGV4aXQgbG9vcCBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHByb2JhYmlsaXR5XG4gICAgICAgICAgICAgICAgLy8gRnJvbSB0aGUgWUlOIHBhcGVyOiBUaGUgdGhyZXNob2xkIGRldGVybWluZXMgdGhlIGxpc3Qgb2ZcbiAgICAgICAgICAgICAgICAvLyBjYW5kaWRhdGVzIGFkbWl0dGVkIHRvIHRoZSBzZXQsIGFuZCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJvcG9ydGlvbiBvZiBhcGVyaW9kaWMgcG93ZXIgdG9sZXJhdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGEgcGVyaW9kaWMgc2lnbmFsLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugd2FudCB0aGUgcGVyaW9kaWNpdHkgYW5kIGFuZCBub3QgYXBlcmlvZGljaXR5OlxuICAgICAgICAgICAgICAgIC8vIHBlcmlvZGljaXR5ID0gMSAtIGFwZXJpb2RpY2l0eVxuICAgICAgICAgICAgICAgIHByb2JhYmlsaXR5ID0gMSAtIHlpbkJ1ZmZlclt0YXVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIHBpdGNoIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgICAgaWYgKHRhdSA9PT0geWluQnVmZmVyTGVuZ3RoIHx8IHlpbkJ1ZmZlclt0YXVdID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcHJvYmFiaWxpdHkgdG9vIGxvdywgcmV0dXJuIC0xLlxuICAgICAgICBpZiAocHJvYmFiaWxpdHkgPCBwcm9iYWJpbGl0eVRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgc3RlcCA1IG9mIHRoZSBBVUJJT19ZSU4gcGFwZXIuIEl0IHJlZmluZXMgdGhlIGVzdGltYXRlZCB0YXVcbiAgICAgICAgICogdmFsdWUgdXNpbmcgcGFyYWJvbGljIGludGVycG9sYXRpb24uIFRoaXMgaXMgbmVlZGVkIHRvIGRldGVjdCBoaWdoZXJcbiAgICAgICAgICogZnJlcXVlbmNpZXMgbW9yZSBwcmVjaXNlbHkuIFNlZSBodHRwOi8vZml6eWthLnVtay5wbC9ucmJvb2svYzEwLTIucGRmIGFuZFxuICAgICAgICAgKiBmb3IgbW9yZSBiYWNrZ3JvdW5kXG4gICAgICAgICAqIGh0dHA6Ly9mZWRjLndpd2kuaHUtYmVybGluLmRlL3hwbG9yZS90dXRvcmlhbHMveGVnYm9odG1sbm9kZTYyLmh0bWxcbiAgICAgICAgICovXG4gICAgICAgIHZhciBiZXR0ZXJUYXUsIHgwLCB4MjtcbiAgICAgICAgaWYgKHRhdSA8IDEpIHtcbiAgICAgICAgICAgIHgwID0gdGF1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeDAgPSB0YXUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXUgKyAxIDwgeWluQnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICB4MiA9IHRhdSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4MiA9IHRhdTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDAgPT09IHRhdSkge1xuICAgICAgICAgICAgaWYgKHlpbkJ1ZmZlclt0YXVdIDw9IHlpbkJ1ZmZlclt4Ml0pIHtcbiAgICAgICAgICAgICAgICBiZXR0ZXJUYXUgPSB0YXU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZXR0ZXJUYXUgPSB4MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4MiA9PT0gdGF1KSB7XG4gICAgICAgICAgICBpZiAoeWluQnVmZmVyW3RhdV0gPD0geWluQnVmZmVyW3gwXSkge1xuICAgICAgICAgICAgICAgIGJldHRlclRhdSA9IHRhdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJldHRlclRhdSA9IHgwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHMwID0geWluQnVmZmVyW3gwXTtcbiAgICAgICAgICAgIHZhciBzMSA9IHlpbkJ1ZmZlclt0YXVdO1xuICAgICAgICAgICAgdmFyIHMyID0geWluQnVmZmVyW3gyXTtcbiAgICAgICAgICAgIC8vIGZpeGVkIEFVQklPIGltcGxlbWVudGF0aW9uLCB0aGFua3MgdG8gS2FybCBIZWxnYXNvbjpcbiAgICAgICAgICAgIC8vICgyLjBmICogczEgLSBzMiAtIHMwKSB3YXMgaW5jb3JyZWN0bHkgbXVsdGlwbGllZCB3aXRoIC0xXG4gICAgICAgICAgICBiZXR0ZXJUYXUgPSB0YXUgKyAoczIgLSBzMCkgLyAoMiAqICgyICogczEgLSBzMiAtIHMwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbXBsZVJhdGUgLyBiZXR0ZXJUYXU7XG4gICAgfTtcbn1cbmV4cG9ydHMuWUlOID0gWUlOO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/detectors/yin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pitchfinder/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar yin_1 = __webpack_require__(/*! ./detectors/yin */ \"(rsc)/./node_modules/pitchfinder/lib/detectors/yin.js\");\nexports.YIN = yin_1.YIN;\nvar amdf_1 = __webpack_require__(/*! ./detectors/amdf */ \"(rsc)/./node_modules/pitchfinder/lib/detectors/amdf.js\");\nexports.AMDF = amdf_1.AMDF;\nvar acf2plus_1 = __webpack_require__(/*! ./detectors/acf2plus */ \"(rsc)/./node_modules/pitchfinder/lib/detectors/acf2plus.js\");\nexports.ACF2PLUS = acf2plus_1.ACF2PLUS;\nvar dynamic_wavelet_1 = __webpack_require__(/*! ./detectors/dynamic_wavelet */ \"(rsc)/./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js\");\nexports.DynamicWavelet = dynamic_wavelet_1.DynamicWavelet;\nvar macleod_1 = __webpack_require__(/*! ./detectors/macleod */ \"(rsc)/./node_modules/pitchfinder/lib/detectors/macleod.js\");\nexports.Macleod = macleod_1.Macleod;\nvar frequencies_1 = __webpack_require__(/*! ./tools/frequencies */ \"(rsc)/./node_modules/pitchfinder/lib/tools/frequencies.js\");\nexports.frequencies = frequencies_1.frequencies;\nexports[\"default\"] = {\n    YIN: yin_1.YIN,\n    AMDF: amdf_1.AMDF,\n    ACF2PLUS: acf2plus_1.ACF2PLUS,\n    DynamicWavelet: dynamic_wavelet_1.DynamicWavelet,\n    Macleod: macleod_1.Macleod,\n    frequencies: frequencies_1.frequencies,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksbUJBQU8sQ0FBQyw4RUFBaUI7QUFDckMsV0FBVztBQUNYLGFBQWEsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDdkMsWUFBWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLHdGQUFzQjtBQUMvQyxnQkFBZ0I7QUFDaEIsd0JBQXdCLG1CQUFPLENBQUMsc0dBQTZCO0FBQzdELHNCQUFzQjtBQUN0QixnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDN0MsZUFBZTtBQUNmLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNqRCxtQkFBbUI7QUFDbkIsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL21udC9jL1VzZXJzL2FuZHl6L0Rvd25sb2Fkcy9BY291c3RpY0FJL25vZGVfbW9kdWxlcy9waXRjaGZpbmRlci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeWluXzEgPSByZXF1aXJlKFwiLi9kZXRlY3RvcnMveWluXCIpO1xuZXhwb3J0cy5ZSU4gPSB5aW5fMS5ZSU47XG52YXIgYW1kZl8xID0gcmVxdWlyZShcIi4vZGV0ZWN0b3JzL2FtZGZcIik7XG5leHBvcnRzLkFNREYgPSBhbWRmXzEuQU1ERjtcbnZhciBhY2YycGx1c18xID0gcmVxdWlyZShcIi4vZGV0ZWN0b3JzL2FjZjJwbHVzXCIpO1xuZXhwb3J0cy5BQ0YyUExVUyA9IGFjZjJwbHVzXzEuQUNGMlBMVVM7XG52YXIgZHluYW1pY193YXZlbGV0XzEgPSByZXF1aXJlKFwiLi9kZXRlY3RvcnMvZHluYW1pY193YXZlbGV0XCIpO1xuZXhwb3J0cy5EeW5hbWljV2F2ZWxldCA9IGR5bmFtaWNfd2F2ZWxldF8xLkR5bmFtaWNXYXZlbGV0O1xudmFyIG1hY2xlb2RfMSA9IHJlcXVpcmUoXCIuL2RldGVjdG9ycy9tYWNsZW9kXCIpO1xuZXhwb3J0cy5NYWNsZW9kID0gbWFjbGVvZF8xLk1hY2xlb2Q7XG52YXIgZnJlcXVlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL3Rvb2xzL2ZyZXF1ZW5jaWVzXCIpO1xuZXhwb3J0cy5mcmVxdWVuY2llcyA9IGZyZXF1ZW5jaWVzXzEuZnJlcXVlbmNpZXM7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgWUlOOiB5aW5fMS5ZSU4sXG4gICAgQU1ERjogYW1kZl8xLkFNREYsXG4gICAgQUNGMlBMVVM6IGFjZjJwbHVzXzEuQUNGMlBMVVMsXG4gICAgRHluYW1pY1dhdmVsZXQ6IGR5bmFtaWNfd2F2ZWxldF8xLkR5bmFtaWNXYXZlbGV0LFxuICAgIE1hY2xlb2Q6IG1hY2xlb2RfMS5NYWNsZW9kLFxuICAgIGZyZXF1ZW5jaWVzOiBmcmVxdWVuY2llc18xLmZyZXF1ZW5jaWVzLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pitchfinder/lib/tools/frequencies.js":
/*!***********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/tools/frequencies.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_FREQUENCIES_PARAMS = {\n    tempo: 120,\n    quantization: 4,\n    sampleRate: 44100,\n};\nfunction pitchConsensus(detectors, chunk) {\n    var pitches = detectors\n        .map(function (fn) { return fn(chunk); })\n        .filter(function (value) { return value !== null; })\n        .sort(function (a, b) { return a - b; });\n    // In the case of one pitch, return it.\n    if (pitches.length === 1) {\n        return pitches[0];\n        // In the case of two pitches, return the geometric mean if they\n        // are close to each other, and the lower pitch otherwise.\n    }\n    else if (pitches.length === 2) {\n        var first = pitches[0], second = pitches[1];\n        return first * 2 > second ? Math.sqrt(first * second) : first;\n        // In the case of three or more pitches, filter away the extremes\n        // if they are very extreme, then take the geometric mean.\n    }\n    else {\n        var first = pitches[0];\n        var second = pitches[1];\n        var secondToLast = pitches[pitches.length - 2];\n        var last = pitches[pitches.length - 1];\n        var filtered1 = first * 2 > second ? pitches : pitches.slice(1);\n        var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n        return Math.pow(filtered2.reduce(function (t, p) { return t * p; }, 1), 1 / filtered2.length);\n    }\n}\nfunction frequencies(detector, float32AudioBuffer, options) {\n    if (options === void 0) { options = {}; }\n    var config = __assign(__assign({}, exports.DEFAULT_FREQUENCIES_PARAMS), options);\n    var tempo = config.tempo, quantization = config.quantization, sampleRate = config.sampleRate;\n    var bufferLength = float32AudioBuffer.length;\n    var chunkSize = Math.round((sampleRate * 60) / (quantization * tempo));\n    var getPitch;\n    if (Array.isArray(detector)) {\n        getPitch = pitchConsensus.bind(null, detector);\n    }\n    else {\n        getPitch = detector;\n    }\n    var pitches = [];\n    for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n        var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n        var pitch = getPitch(chunk);\n        pitches.push(pitch);\n    }\n    return pitches;\n}\nexports.frequencies = frequencies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGl0Y2hmaW5kZXIvbGliL3Rvb2xzL2ZyZXF1ZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQsbUNBQW1DLHdCQUF3QjtBQUMzRCxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL21udC9jL1VzZXJzL2FuZHl6L0Rvd25sb2Fkcy9BY291c3RpY0FJL25vZGVfbW9kdWxlcy9waXRjaGZpbmRlci9saWIvdG9vbHMvZnJlcXVlbmNpZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0ZSRVFVRU5DSUVTX1BBUkFNUyA9IHtcbiAgICB0ZW1wbzogMTIwLFxuICAgIHF1YW50aXphdGlvbjogNCxcbiAgICBzYW1wbGVSYXRlOiA0NDEwMCxcbn07XG5mdW5jdGlvbiBwaXRjaENvbnNlbnN1cyhkZXRlY3RvcnMsIGNodW5rKSB7XG4gICAgdmFyIHBpdGNoZXMgPSBkZXRlY3RvcnNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKGNodW5rKTsgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBudWxsOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIG9uZSBwaXRjaCwgcmV0dXJuIGl0LlxuICAgIGlmIChwaXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGl0Y2hlc1swXTtcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBpdGNoZXMsIHJldHVybiB0aGUgZ2VvbWV0cmljIG1lYW4gaWYgdGhleVxuICAgICAgICAvLyBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBsb3dlciBwaXRjaCBvdGhlcndpc2UuXG4gICAgfVxuICAgIGVsc2UgaWYgKHBpdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHBpdGNoZXNbMF0sIHNlY29uZCA9IHBpdGNoZXNbMV07XG4gICAgICAgIHJldHVybiBmaXJzdCAqIDIgPiBzZWNvbmQgPyBNYXRoLnNxcnQoZmlyc3QgKiBzZWNvbmQpIDogZmlyc3Q7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHRocmVlIG9yIG1vcmUgcGl0Y2hlcywgZmlsdGVyIGF3YXkgdGhlIGV4dHJlbWVzXG4gICAgICAgIC8vIGlmIHRoZXkgYXJlIHZlcnkgZXh0cmVtZSwgdGhlbiB0YWtlIHRoZSBnZW9tZXRyaWMgbWVhbi5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHBpdGNoZXNbMF07XG4gICAgICAgIHZhciBzZWNvbmQgPSBwaXRjaGVzWzFdO1xuICAgICAgICB2YXIgc2Vjb25kVG9MYXN0ID0gcGl0Y2hlc1twaXRjaGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgbGFzdCA9IHBpdGNoZXNbcGl0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGZpbHRlcmVkMSA9IGZpcnN0ICogMiA+IHNlY29uZCA/IHBpdGNoZXMgOiBwaXRjaGVzLnNsaWNlKDEpO1xuICAgICAgICB2YXIgZmlsdGVyZWQyID0gc2Vjb25kVG9MYXN0ICogMiA+IGxhc3QgPyBmaWx0ZXJlZDEgOiBmaWx0ZXJlZDEuc2xpY2UoMCwgLTEpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coZmlsdGVyZWQyLnJlZHVjZShmdW5jdGlvbiAodCwgcCkgeyByZXR1cm4gdCAqIHA7IH0sIDEpLCAxIC8gZmlsdGVyZWQyLmxlbmd0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJlcXVlbmNpZXMoZGV0ZWN0b3IsIGZsb2F0MzJBdWRpb0J1ZmZlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBleHBvcnRzLkRFRkFVTFRfRlJFUVVFTkNJRVNfUEFSQU1TKSwgb3B0aW9ucyk7XG4gICAgdmFyIHRlbXBvID0gY29uZmlnLnRlbXBvLCBxdWFudGl6YXRpb24gPSBjb25maWcucXVhbnRpemF0aW9uLCBzYW1wbGVSYXRlID0gY29uZmlnLnNhbXBsZVJhdGU7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGZsb2F0MzJBdWRpb0J1ZmZlci5sZW5ndGg7XG4gICAgdmFyIGNodW5rU2l6ZSA9IE1hdGgucm91bmQoKHNhbXBsZVJhdGUgKiA2MCkgLyAocXVhbnRpemF0aW9uICogdGVtcG8pKTtcbiAgICB2YXIgZ2V0UGl0Y2g7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGV0ZWN0b3IpKSB7XG4gICAgICAgIGdldFBpdGNoID0gcGl0Y2hDb25zZW5zdXMuYmluZChudWxsLCBkZXRlY3Rvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQaXRjaCA9IGRldGVjdG9yO1xuICAgIH1cbiAgICB2YXIgcGl0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBidWZmZXJMZW5ndGggLSBjaHVua1NpemU7IGkgPD0gbWF4OyBpICs9IGNodW5rU2l6ZSkge1xuICAgICAgICB2YXIgY2h1bmsgPSBmbG9hdDMyQXVkaW9CdWZmZXIuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSk7XG4gICAgICAgIHZhciBwaXRjaCA9IGdldFBpdGNoKGNodW5rKTtcbiAgICAgICAgcGl0Y2hlcy5wdXNoKHBpdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpdGNoZXM7XG59XG5leHBvcnRzLmZyZXF1ZW5jaWVzID0gZnJlcXVlbmNpZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pitchfinder/lib/tools/frequencies.js\n");

/***/ })

};
;